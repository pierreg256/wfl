// Generated by CoffeeScript 1.3.3
(function() {
  var Decider, Response, Swf, amazon, awssum, inspect, routeUtils,
    __slice = [].slice;

  awssum = require('awssum');

  amazon = awssum.load('amazon/amazon');

  Swf = awssum.load('amazon/swf').Swf;

  inspect = require('eyes').inspector();

  routeUtils = require('../utils/routes');

  Response = (function() {

    function Response(app, swf, token, logger) {
      this.app = app;
      this.swf = swf;
      this.token = token;
      this.logger = logger;
    }

    Response.prototype.scheduleActivity = function(activityName, inputValue) {
      var acti, taskList;
      if (inputValue == null) {
        inputValue = "";
      }
      if (typeof inputValue !== "string") {
        inputValue = "" + JSON.stringify(inputValue);
      }
      taskList = "";
      for (acti in this.app.options.activities) {
        if (this.app.options.activities[acti].name === activityName) {
          taskList = this.app.options.activities[acti].taskList;
        }
      }
      return this._scheduleActivityTask(activityName, taskList, inputValue);
    };

    Response.prototype.cancel = function(reason) {
      return this._failWorkflowExecution(reason);
    };

    Response.prototype.end = function(result) {
      var decisions;
      if (result == null) {
        result = "";
      }
      if (typeof result !== "string") {
        result = "" + JSON.stringify(result);
      }
      decisions = [
        {
          "decisionType": "CompleteWorkflowExecution",
          "completeWorkflowExecutionDecisionAttributes": {
            "result": result
          }
        }
      ];
      return this._respondCompleted(decisions);
    };

    Response.prototype._respondCompleted = function(decisions, callBack) {
      var swfCfg,
        _this = this;
      swfCfg = {
        "TaskToken": this.token,
        "Decisions": decisions
      };
      return this.app.swf.RespondDecisionTaskCompleted(swfCfg, function(err, data) {
        if (callBack != null) {
          return process.nextTick(function() {
            return callBack(err, data);
          });
        } else {
          if (err != null) {
            console.log("Error executing: respondCompleted");
          }
          if (data != null) {
            return console.log("Successfully executed: respondCompleted");
          }
        }
      });
    };

    Response.prototype._completeWorkflowExecution = function(callBack) {
      var decisions;
      decisions = [
        {
          "decisionType": "CompleteWorkflowExecution",
          "completeWorkflowExecutionDecisionAttributes": {
            "result": "Finished !"
          }
        }
      ];
      return this._respondCompleted(decisions, callBack);
    };

    Response.prototype._failWorkflowExecution = function() {
      var cBack, callBack, decisions, details, reason, _i, _ref;
      reason = arguments[0], details = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callBack = arguments[_i++];
      decisions = [
        {
          "decisionType": "FailWorkflowExecution",
          "failWorkflowExecutionDecisionAttributes": {
            "reason": reason,
            "details": (_ref = details[0]) != null ? _ref : "none provided by the user"
          }
        }
      ];
      cBack = callBack != null ? callBack : function(err) {
        if (err != null) {
          return console.log("Error executing: failWorkflowExecution");
        }
      };
      return this._respondCompleted(decisions, cBack);
    };

    Response.prototype._scheduleActivityTask = function(activityName, taskList, inputValue, callBack) {
      var cBack, decisions;
      decisions = [
        {
          "decisionType": "ScheduleActivityTask",
          "scheduleActivityTaskDecisionAttributes": {
            "activityId": activityName + "-" + ((Math.random() + "").substr(2)),
            "activityType": {
              "name": activityName,
              "version": "1.0"
            },
            "input": inputValue,
            "taskList": {
              "name": taskList
            }
          }
        }
      ];
      cBack = callBack != null ? callBack : function(err) {
        if (err != null) {
          inspect(err, "Error executing: scheduleActivityTask");
          return process.exit(1);
        }
      };
      return this._respondCompleted(decisions, cBack);
    };

    return Response;

  })();

  Decider = (function() {

    function Decider(app) {
      var swfCfg, _ref, _ref1,
        _this = this;
      this.app = app;
      swfCfg = {
        'accessKeyId': this.app.options.accessKeyId,
        'secretAccessKey': this.app.options.secretAccessKey,
        'region': this.app.options.region
      };
      this.swf = new Swf(swfCfg);
      if ((_ref = this.name) == null) {
        this.name = "" + this.app.options.domain + "-" + this.app.options.name + "-decider";
      }
      if ((_ref1 = this.taskList) == null) {
        this.taskList = function() {
          return "" + _this.app.options.domain + "-" + _this.app.options.name + "-decider-default-tasklist";
        };
      }
      this.routes = [];
    }

    Decider.prototype.addDecision = function(route, decisionFn) {
      return this.routes.push({
        "route": route,
        "decisionTask": decisionFn
      });
    };

    Decider.prototype.listen = function() {
      var _this = this;
      return process.nextTick(function() {
        return _this.poll();
      });
    };

    Decider.prototype.poll = function() {
      var swfCfg,
        _this = this;
      this.app.logger.verbose("Polling for next decision in list:" + (this.app.options.decider.taskList()));
      swfCfg = {
        'Domain': this.app.options.domain,
        'TaskList': {
          'name': "" + (this.app.options.decider.taskList())
        }
      };
      return this.swf.PollForDecisionTask(swfCfg, function(err, data) {
        var body, nextPageToken, token;
        if (err != null) {
          _this.logger.critical("Unexpected Error polling decision task, see the following details for more info");
          inspect(err, "Error returned by PollForDecisionTask");
          process.exit(1.);
        } else {
          body = data.Body;
          token = body.taskToken;
          nextPageToken = body.nextPageToken;
          if (nextPageToken != null) {
            _this.app.logger.error("Multipage history not yet implemented. Quitting");
            process.exit(1);
          }
          if (token != null) {
            routeUtils.makeRoute(body.events, function(routeError, request) {
              var found, response, tmpRoute;
              response = new Response(_this.app, _this.swf, token, _this.logger);
              found = false;
              for (tmpRoute in _this.routes) {
                if (_this.routes[tmpRoute].route === request.url) {
                  _this.app.logger.debug("Making following decision: " + _this.routes[tmpRoute].route);
                  _this.routes[tmpRoute].decisionTask(request, response);
                  found = true;
                }
              }
              if (!found) {
                _this.app.logger.warn("no suitable route found for url: " + request.url);
                return response.cancel("no suitable route found for url: " + request.url + " ");
              }
            });
          } else {
            _this.app.logger.verbose("No decision in the pipe for " + (_this.app.options.decider.taskList()));
          }
        }
        return process.nextTick(function() {
          return _this.poll();
        });
      });
    };

    return Decider;

  })();

  exports.Decider = Decider;

}).call(this);
